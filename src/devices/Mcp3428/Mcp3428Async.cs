// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System;
using System.Buffers.Binary;
using System.Collections.Generic;
using System.Device.I2c;
using System.IO;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.Threading.Tasks;

namespace Iot.Device.Mcp3428
{
    using static Helpers;
    /// <summary>
    /// Async API is mostly useful for greater resolutions and one-shot mode, when conversion time can be significant.
    /// Implements the <see cref="Iot.Device.Mcp3428.Mcp3428" />
    /// </summary>
    /// <seealso cref="Iot.Device.Mcp3428.Mcp3428" />
    /// <autogeneratedoc />
    public partial class Mcp3428
    {
        private int _asyncThreshold = 20;

        /// <summary>
        /// One-shot read as an asynchronous operation. Initiates read and waits for it to finish.
        /// Async API was required as reading in 16bit resolution can take more than 60ms.
        /// </summary>
        /// <param name="channel">The channel.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>ValueTask.</returns>
        /// <exception cref="System.IO.IOException">
        /// Device is not in One-Shot mode
        /// or
        /// ADC Conversion was not ready after {tries}
        /// </exception>
        /// <autogeneratedoc />
        protected ValueTask OneShotReadAsync(int channel = -1, CancellationToken cancellationToken = default)
        {
            if (Mode != ModeEnum.OneShot)
                throw new IOException("Device is not in One-Shot mode");

            _isReadyBit = false;
            var conf = Helpers.SetReadyBit(LastConfigByte, false);
            if (channel >= 0 && channel != LastChannel)
            {
                conf = Helpers.SetChannelBits(conf, channel);
            }

            WriteConfig(conf);

            return WaitForConversionAsync(TimeSpan.FromMilliseconds(WaitTime), cancellationToken: cancellationToken);
        }

        protected async ValueTask<ConversionResult> ReadValueAsync(int channel = -1, CancellationToken cancellationToken = default)
        {
            if (Mode == ModeEnum.OneShot)
            {
                await OneShotReadAsync(channel, cancellationToken);
            }
            else
            {
                if (channel > 0 && channel != LastChannel)
                {
                    var conf = SetChannelBits(LastConfigByte, channel);
                    WriteConfig(conf);
                }

                await WaitForConversionAsync(TimeSpan.FromMilliseconds(WaitTime / 5), cancellationToken: cancellationToken); // In continuous mode poll more often
            }
            cancellationToken.ThrowIfCancellationRequested();

            //var value = BinaryPrimitives.ReadInt16LittleEndian(_readBuffer.AsSpan().Slice(1, 2));
            var value = BinaryPrimitives.ReadInt16BigEndian(_readBuffer.AsSpan().Slice(0, 2));
            LastConversion =new ConversionResult(_lastChannel, value, Resolution);

            return LastConversion;
        }

        protected async ValueTask WaitForConversionAsync(TimeSpan? waitSpan = null, Action<int> progressCallback = null, CancellationToken cancellationToken = default)
        {
            waitSpan = waitSpan ?? TimeSpan.FromMilliseconds(WaitTime);
            var allms = 0;
            _isReadyBit = false;
            while (!_isReadyBit && !cancellationToken.IsCancellationRequested)
            {
                _i2cDevice.Read(_readBuffer);
                ReadConfigByte(LastConfigByte);
                if (_isReadyBit)
                    break;

                await Task.Delay(waitSpan.Value, cancellationToken);
                allms += (int)(waitSpan.Value.TotalMilliseconds);
                progressCallback?.Invoke(allms);
            }
            cancellationToken.ThrowIfCancellationRequested();
        }

        /// <summary>
        /// Reads the channel. Async API is mostly useful for greater resolutions and one-shot mode, when conversion time can be significant.
        /// </summary>
        /// <param name="channel">The channel.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>ValueTask&lt;System.Double&gt;.</returns>
        /// <autogeneratedoc />
        public async ValueTask<double> ReadChannel(int channel, CancellationToken cancellationToken = default)
        {
            if ((Resolution == ResolutionEnum.Bit12 && Mode == ModeEnum.Continuous)|| WaitTime < _asyncThreshold)
                return ReadValue(channel);

            await ReadValueAsync(channel, cancellationToken);
            return LastConversion.Voltage;
        }
    }
}
