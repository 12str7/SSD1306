// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System;
using System.Buffers.Binary;
using System.Collections.Generic;
using System.Device.I2c;
using System.IO;
using System.Runtime.CompilerServices;
using System.Threading;

namespace Iot.Device.Mcp3428
{
    using static Helpers;


    public class Mcp3428 : IDisposable
    {
        public Mcp3428(I2cDevice i2CDevice) : this(i2CDevice,4)
        {
        }

        public Mcp3428(I2cDevice i2CDevice, ModeEnum mode = ModeEnum.Continuous,
            ResolutionEnum resolution = ResolutionEnum.Bit12, GainEnum pgaGain = GainEnum.X1) : this(i2CDevice)
        {
            SetConfig(0, resolution: resolution, mode: mode, pgaGain: pgaGain);
        }

        /// <summary>
        /// Protected constructor to easily generate MCP3426/7 devices whose only difference is channel count and I2C address
        /// </summary>
        /// <param name="i2CDevice">The i2 c device.</param>
        /// <param name="channels">The channels.</param>
        /// <autogeneratedoc />
        protected Mcp3428(I2cDevice i2CDevice, int channels)
        {
            _i2cDevice = i2CDevice;
            ChannelCount = channels;
            ReadValue(); // Don't like this in constructor, makes sure props are valid
        }

        /// <summary>
        /// Gets the last transmitted bytes. Debug function
        /// </summary>
        /// <value>The last bytes.</value>
        /// <autogeneratedoc />
        public ReadOnlyMemory<byte> LastBytes => _readBuffer;

        /// <summary>
        /// Channel most recently read
        /// </summary>
        /// <value>The last channel.</value>
        /// <autogeneratedoc />
        public byte LastChannel => LastConversion.Channel;

        public ModeEnum Mode
        {
            get => _mode;
            set
            {
                WriteConfig(SetModeBit(LastConfigByte, value));
                _mode = value;
            }
        }

        /// <summary>
        /// Gets or sets the input gain.
        /// </summary>
        /// <value>The pga gain.</value>
        /// <autogeneratedoc />
        public GainEnum PGAGain
        {
            get => _pgaGain;
            set
            {
                WriteConfig(SetGainBits(LastConfigByte, value));
                _pgaGain = value;
            }
        }

        /// <summary>
        /// Gets or sets the bit resolution of the result.
        /// </summary>
        /// <value>The resolution.</value>
        /// <autogeneratedoc />
        public ResolutionEnum Resolution
        {
            get => _resolution;
            set
            {
                WriteConfig(SetResolutionBits(LastConfigByte, value));
                _resolution = value;
                //WaitTime = (int)(1000.0 / UpdateFrequency(_resolution));
            }
        }

        public void Dispose()
        {
        }

        /// <summary>
        /// Reads the channel.
        /// </summary>
        /// <param name="channel">The channel.</param>
        /// <returns>System.Double.</returns>
        /// <autogeneratedoc />
        public double ReadChannel(int channel)
        {
            return ReadValue(channel);
        }

        protected const int MaxRetries = 50;
        protected readonly I2cDevice _i2cDevice;
        protected readonly byte[] _readBuffer = new byte[3];

        protected bool _isReadyBit = false;
        protected byte _lastChannel = 0xFF;
        private ConversionResult _lastConversion;
        protected ModeEnum _mode = ModeEnum.Continuous;
        //Config params
        protected GainEnum _pgaGain = GainEnum.X1;

        protected ResolutionEnum _resolution = ResolutionEnum.Bit12;

        protected byte LastConfigByte => _readBuffer[2];

        /// <summary>
        /// Initiates One-shot reading and waits for the conversion to finish.
        /// </summary>
        /// <param name="channel">The channel.</param>
        /// <exception cref="System.IO.IOException">
        /// Device is not in One-Shot mode
        /// or
        /// ADC Conversion was not ready after {tries}
        /// </exception>
        /// <autogeneratedoc />
        protected void OneShotRead(int channel = -1)
        {
            if (Mode != ModeEnum.OneShot)
                throw new IOException("Device is not in One-Shot mode");

            _isReadyBit = false;
            var conf = SetReadyBit(LastConfigByte, false);
            if (channel >= 0 && channel != LastChannel)
            {
                conf = SetChannelBits(conf, channel);
            }

            WriteConfig(conf);
            using (var source = new CancellationTokenSource(TimeSpan.FromMilliseconds(WaitTime*5)))
            {
                WaitForConversion(TimeSpan.FromMilliseconds(WaitTime), cancellationToken:source.Token);

            if (!_isReadyBit)
            {
                throw new IOException($"ADC Conversion was not ready after {WaitTime*5} ms.");
            }
            }
        }

        protected void WaitForConversion(TimeSpan? waitSpan = null, Action<int> progressCallback = null, CancellationToken cancellationToken = default)
        {
            waitSpan = waitSpan ?? TimeSpan.FromMilliseconds(WaitTime);
            var allms = 0;
            _isReadyBit = false;
            while (!_isReadyBit && !cancellationToken.IsCancellationRequested)
            {
                _i2cDevice.Read(_readBuffer);
                ReadConfigByte(LastConfigByte);
                if (_isReadyBit)
                    break;

                Thread.Sleep(waitSpan.Value);
                cancellationToken.ThrowIfCancellationRequested();
                allms += (int)(waitSpan.Value.TotalMilliseconds);
                progressCallback?.Invoke(allms);
            }
            cancellationToken.ThrowIfCancellationRequested();
        }

        protected void ReadConfigByte(byte config)
        {
            _isReadyBit = (config & Helpers.Masks.ReadyMask) == 0; // Negated bit
            _lastChannel = (byte)((config & Helpers.Masks.ChannelMask) >> 5);
            _mode = (ModeEnum)(config & Helpers.Masks.ModeMask);
            _pgaGain = (GainEnum)(config & Helpers.Masks.GainMask);
            _resolution = (ResolutionEnum)(config & Helpers.Masks.ResolutionMask);
        }

        protected double ReadValue(int channel = -1)
        {
            if (Mode == ModeEnum.OneShot)
            {
                OneShotRead(channel);
            }
            else
            {
                if (channel > 0 && channel != LastChannel)
                {
                    var conf = SetChannelBits(LastConfigByte, channel);
                    WriteConfig(conf);
                }

                using (var source = new CancellationTokenSource(TimeSpan.FromMilliseconds(WaitTime * 5)))
                {
                    WaitForConversion(TimeSpan.FromMilliseconds(WaitTime / 5), cancellationToken: source.Token);
                }
            }

            //var value = BinaryPrimitives.ReadInt16LittleEndian(_readBuffer.AsSpan().Slice(1, 2));
            var value = BinaryPrimitives.ReadInt16BigEndian(_readBuffer.AsSpan().Slice(0, 2));
            LastConversion = new ConversionResult(_lastChannel, value, Resolution);
            //_lastValue = value * LSBValue(Resolution);
            return LastConversion.Voltage;
        }

        /// <summary>
        /// Write configuration register and read back value
        /// </summary>
        /// <param name="channel">The channel.</param>
        /// <param name="mode">The mode.</param>
        /// <param name="resolution">The resolution.</param>
        /// <param name="pgaGain">The pga gain.</param>
        /// <returns><c>true</c> if all values are set correctly, <c>false</c> otherwise.</returns>
        /// <autogeneratedoc />
        protected bool SetConfig(int channel = 0, ModeEnum mode = ModeEnum.Continuous,
            ResolutionEnum resolution = ResolutionEnum.Bit12, GainEnum pgaGain = GainEnum.X1)
        {
            if (channel < 0 || channel > ChannelCount-1) throw new ArgumentOutOfRangeException(nameof(channel));
            byte conf = 0;
            var ok = true;
            conf = SetModeBit(conf, mode);
            conf = SetChannelBits(conf, channel);
            conf = SetGainBits(conf, pgaGain);
            conf = SetResolutionBits(conf, resolution);
            conf = SetReadyBit(conf, false);

            _i2cDevice.WriteByte(conf);

            _i2cDevice.Read(_readBuffer);
            ReadConfigByte(LastConfigByte);

            
            if (_lastChannel != channel)
            {
                Console.WriteLine($"Channel update failed from {_lastChannel} to {channel}");
                ok = false;
            }
            if (Resolution != resolution)
            {
                Console.WriteLine($"Resolution update failed from {Resolution} to {resolution}");
                ok = false;
            }
            if (mode != Mode)
            {
                Console.WriteLine($"Mode update failed from {Mode} to {mode}");
                ok = false;
            }
            if (PGAGain != pgaGain)
            {
                Console.WriteLine($"PGAGain update failed from {PGAGain} to {pgaGain}");
                ok = false;
            }

            if (!ok)
            {   // Only use console on error
                Console.WriteLine($"Sent config byte {conf:X}, received {LastConfigByte:X}");
            }
            return ok;
        }

        protected int WaitTime => (int)(1000.0 / UpdateFrequency(Resolution));
        
        public int ChannelCount { get; }
                
        protected ConversionResult LastConversion
        {
            get
            {
                return _lastConversion;
            }
            set
            {
                _lastConversion = value;
                OnConversion?.Invoke(this, _lastConversion);
            }
        }

        public event EventHandler<ConversionResult> OnConversion;

        protected void WriteConfig(byte configByte)
        {
            _i2cDevice.WriteByte(configByte);
            //_i2cDevice.Read(_readBuffer);
            //ReadConfigByte(_lastConfigByte);
        }

        public static int AddressFromPins(PinState Adr0, PinState Adr1) { return Helpers.AddressFromPins(Adr0, Adr1); }
    }
}
