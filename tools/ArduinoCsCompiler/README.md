# ArduinoCsCompiler

This tool allows to compile a .NET assembly into a form that can be executed on microcontrollers with limited storage and RAM. You can test and debug your application on the PC and then transfer it to a supported microcontroller (MCU). Once the application has been loaded to the MCU, a connection to the PC is no longer necessary and the program runs independently. Read on for instructions to get started. 

At the moment, the following microcontrollers are supported:
- ESP32
- Arduino Due (with some limitations, see below)

Additionally, the microcontroler can be simulated on the PC for additional testing and debugging possibilities.

## Overview

To execute .NET code, the microcontroler needs to be programmed with a firmware that is able to understand the IL (Intermediate language) code generated by the C# (or VB) compiler. We call this part the "Firmware". It is loaded using tools supplied from the microcontroler vendors. For compiling and uploading, the instructions use the Arduino command line interface. The Arduino IDE can also be used after some initial steps. 

After the firmware has been loaded, the compiler can talk to the microcontroler and upload program code. The program will start executing right after the upload or after the microcontroler has been reset.

## Building the compiler

Enter the checkout directory where you have checked out the dotnet/iot repository, e.g. `C:\projects\iot` and run `build.cmd`. That builds all the projects in the solution and downloads any dependent packages. The ArduinoCsCompiler executable will be built to `C:\projects\iot\tools\ArduinoCsCompiler\Frontend\bin\Debug\net6.0`. So run `cd tools\ArduinoCsCompiler\Frontend\bin\Debug\net6.0`. Now

> `acs --help`

should give an output like

```text
ArduinoCsCompiler - Version 1.0.0.0
The .NET Foundation
compile    Compile and optionally upload code to a microcontroller. Further options allow to debug the uploaded code.
prepare    Prepare the Arduino runtime for uploading
test       Run various interactive tests on the board
help       Display more information on a specific command.
version    Display version information.
```

## Preparing the microcontroler

These instructions assume your microcontroler is any type of ESP32 board, the Arduino Due requires some additional prerequisites and considerations outlined below. 

These instructions assume you have Visual Studio 2022 installed and a git installation available. Open a "developer command prompt for VS2022" as administrator from the start menu. Some of the following steps are also available from the "Board Manager" and "Library Manager" windows in the Arduino IDE if it is installed. However, the use of the command line is less error-prone for getting everything together for the first time. 

Test you have chocolatey installed (the Windows package manager).

> `choco --version`

If this returns an error instead of printing a version number, install it:

> `powershell -ExecutionPolicy Bypass; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))`

Install the Arduino Command line utility (can be installed alongside the Arduino IDE)

> `choco install arduino-cli`

If running for the first time, initialize the configuration and download the ESP32 toolchain (compiler + tools)

> `arduino-cli config init` 
> `arduino-cli config add board_manager.additional_urls https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_dev_index.json`
> `arduino-cli core update-index`
> `arduino-cli core install esp32:esp32`

It is recommended to use the 2.0.x version of the ESP toolchain (as done above), particularly when WIFI shall be used, because the performance of some operations have been significantly improved. The 1.X version can also be used with some minor code modifications.

Now we are ready to download and install the actual code. Some required libraries:

> `arduino-cli lib install "DHT sensor library"`
> `arduino-cli lib install "Servo"`

The firmata code (protocol and hardware support) as well as the IL execution engine (where %ArduinoRoot% is typically `C:\Users\<your name>\Documents\Arduino`). Due to the way the Arduino library management works, you cannot use a different checkout directory.

> `git clone https://github.com/firmata/ConfigurableFirmata %ArduinoRootDir%\libraries\ConfigurableFirmata`
> `git clone https://github.com/pgrawehr/ExtendedConfigurableFirmata %ArduinoRootDir%\ExtendedConfigurableFirmata`

Before we can finally build the firmware, we need to generate the interface declarations for it. This alligns some important constants between the compiler and the runtime. Switch to the compiler directory `C:\projects\iot\tools\ArduinoCsCompiler\Frontend\bin\Debug\net6.0` and execute: 

> `acs prepare --flashsize 4MiB`

To finally compile the firmware, switch to `%ArduinoRootDir%\ExtendedConfigurableFirmata` and execute

> `arduino-cli compile --fqbn esp32:esp32:esp32:PSRAM=disabled,PartitionScheme=default,CPUFreq=240,FlashMode=qio,FlashFreq=80,FlashSize=4M,UploadSpeed=921600,DebugLevel=none ./ExtendedConfigurableFirmata.ino --warnings default`
> `arduino-cli upload --fqbn espressif:esp32:esp32:PSRAM=disabled,PartitionScheme=default,CPUFreq=240,FlashMode=qio,FlashFreq=80,FlashSize=4M,UploadSpeed=921600,DebugLevel=none ./ExtendedConfigurableFirmata.ino --verbose -p COM4`

Your particular board may require different settings. The valid settings can be seen in the tools menu of the Arduino IDE. If you open `ExtendedConfigurableFirmata.ino` in the IDE, the above steps are performed automatically if you hit the "Upload" button. The IDE has a big list of detailed board types that affect the amount of memory that is available (check the list under Tools->Board->ESP32). 

> Note: Because we previously wrote a custom flash partition file using `acs prepare --flashsize xxx` with the partitions required for the firmware, the IDE setting "Partition Scheme" has no effect. After a successful compile, the compiler will give a message such as `The sketch uses 930973 bytes (71%) of program memory. The maximum is 1310720 Bytes.` **This message is incorrect**. The maximum value indicated comes from the "Partition scheme" selection, while the relevant maximum is the size of the `factory` partition, which can be specified by giving the `--firmwaresize` parameter to the `acs prepare` command (default is 1MiB). If the `factory` partition is smaller than the actual firmware, you might still be able to upload it, but the behavior is undefined. Typically the ESP32 will not boot successfully. 

By default, the Firmware is configured to use the USB connection for communication and software upload. If you edit `ExtendedConfigurableFirmata.ino` you can enable WIFI. This might improve upload speed and allows the ESP32 to use the internet to synchronize its system clock. If WIFI is enabled, the data partition on the Flash storage is accessible using FTP.



## Notes on the use of the Arduino Due

The firmware supports the Arduino Due, but since its memory (512k Flash, 96k RAM) is much smaller than that of the ESP32 some extra effort may be necessary to reduce the code size so that it fits the available flash space. Check out the compiler option `--suppress`. Due to a [known bug in the Arduino Due's standard library](https://arduino.stackexchange.com/questions/80535/memory-allocation-on-arduino-due-never-returns-null), you need to patch the standard library before you use it to compile the firmware for this board. Otherwise, when the runtime runs out of memory, the Due will just crash and stop responding.

Locate the file `C:\Users\Patrick\AppData\Local\Arduino15\packages\arduino\hardware\sam\1.6.12\cores\arduino\syscalls_sam3.c` (if it's not there, you need to install the Arduino Due Toolchain first using the library manager).